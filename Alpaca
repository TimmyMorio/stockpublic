import yfinance as yf
import pandas as pd
from alpaca_trade_api.rest import REST
from ta.momentum import RSIIndicator
import numpy as np

# Alpaca API credentials 
ALPACA_API_KEY = 'PKA2HSAM02FMFG60K4BS'
ALPACA_SECRET_KEY = 'wqwJGiUWdL7Old1ByKvIllHvwxXvH1xtEMEdzAiy'
BASE_URL = 'https://paper-api.alpaca.markets'

# Инициализация клиента Alpaca
api = REST(ALPACA_API_KEY, ALPACA_SECRET_KEY, BASE_URL, api_version='v2')

# Функция для расчета уровней поддержки и сопротивления
def calculate_levels(data, window=90):
    data['Support'] = data['Low'].rolling(window=window).min()
    data['Resistance'] = data['High'].rolling(window=window).max()
    return data

# Проверка открытых позиций
def has_position(symbol):
    try:
        position = api.get_position(symbol)
        qty = float(position.qty)
        return qty > 0
    except:
        return False

# Функция для проверки торговых сигналов и выполнения сделок
def check_trading_signals_and_execute(stock_list, window=90, threshold=0.01, stop_loss=0.07, take_profit=0.25):
    result = []
    failed_tickers = []

    for stock in stock_list:
        try:
            # Загрузка исторических данных
            data = yf.download(stock, period='1y', interval='1d', auto_adjust=False, group_by='ticker')

            if data.empty or data.isnull().values.any():
                print(f"No or invalid data for {stock}. Skipping...")
                failed_tickers.append(stock)
                continue

            # Если данные имеют многоуровневые колонки — преобразуем их
            if isinstance(data.columns, pd.MultiIndex):
                data.columns = data.columns.get_level_values(1)

            # Диагностика: проверка формы данных после преобразования
            print(f"\n--- Diagnosing {stock} ---")
            for col in data.columns:
                print(f"Column: {col}, Shape: {data[col].shape}")

            # Расчет уровней поддержки и сопротивления
            data = calculate_levels(data, window)

            # Расчет индикатора RSI
            close_prices = data['Close']
            rsi_indicator = RSIIndicator(close=close_prices, window=14)
            data['RSI'] = rsi_indicator.rsi()

            # Получение последних значений
            last_close = float(close_prices.iloc[-1])
            last_support = float(data['Support'].iloc[-1])
            last_resistance = float(data['Resistance'].iloc[-1])
            last_rsi = float(data['RSI'].iloc[-1])
            volume_avg = float(data['Volume'].rolling(20).mean().iloc[-1])
            last_volume = float(data['Volume'].iloc[-1])

            # BUY signal
            if (last_close <= last_support * (1 + threshold)) and (last_rsi > 30) and (last_volume > volume_avg):
                result.append({'Stock': stock, 'Type': 'BUY', 'Close': last_close, 'Support': last_support})
                print(f"BUY Signal for {stock} at {last_close}")
                api.submit_order(
                    symbol=stock,
                    qty=1,
                    side='buy',
                    type='market',
                    time_in_force='gtc'
                )

            # SELL signal
            if pd.notnull(last_resistance) and (last_close >= last_resistance * (1 - threshold)) and (last_rsi < 70):
                if has_position(stock):
                    result.append({'Stock': stock, 'Type': 'SELL', 'Close': last_close, 'Resistance': last_resistance})
                    print(f"SELL Signal for {stock} at {last_close}")
                    api.submit_order(
                        symbol=stock,
                        qty=1,
                        side='sell',
                        type='market',
                        time_in_force='gtc'
                    )
                else:
                    print(f"Skipping SELL for {stock} — No position held.")

            # STOP LOSS signal
            if pd.notnull(last_support) and (last_close <= last_support * (1 - stop_loss)):
                if has_position(stock):
                    result.append({'Stock': stock, 'Type': 'STOP LOSS', 'Close': last_close, 'Support': last_support})
                    print(f"STOP LOSS Triggered for {stock} at {last_close}")
                    api.submit_order(
                        symbol=stock,
                          qty=1,
                        side='sell',
                        type='market',
                        time_in_force='gtc'
                    )
                else:
                    print(f"Skipping STOP LOSS for {stock} — No position held.")

            # TAKE PROFIT signal
            if pd.notnull(last_support) and (last_close >= last_support * (1 + take_profit)):
                if has_position(stock):
                    result.append({'Stock': stock, 'Type': 'TAKE PROFIT', 'Close': last_close, 'Support': last_support})
                    print(f"TAKE PROFIT Triggered for {stock} at {last_close}")
                    api.submit_order(
                        symbol=stock,
                        qty=1,
                        side='sell',
                        type='market',
                        time_in_force='gtc'
                    )
                else:
                    print(f"Skipping TAKE PROFIT for {stock} — No position held.")

        except Exception as e:
            print(f"Error for {stock}: {e}")
            failed_tickers.append(stock)

    return pd.DataFrame(result), failed_tickers

# Список акций для проверки
stock_list = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'JNJ', 'V', 'PG', 'JPM',
              'UNH', 'MA', 'HD', 'BAC', 'DIS', 'VZ', 'NFLX', 'ADBE', 'CRM', 'INTC', 'PFE']

# Запуск проверки торговых сигналов и выполнения сделок
results, failed_tickers = check_trading_signals_and_execute(stock_list)

# Вывод результатов
print("\nTrading Signals:")
print(results)

if failed_tickers:
    print("\nFailed tickers:")
    for ticker in failed_tickers:
        print(ticker)
